/*
Todo:
	- handle import statements in collector/resolver (groupings, etc.)
	- built-in casts
	- built-in operations (in progress)
	- string interpolation
	- visibility/access modifiers
		(tls stands for 'top-level statements' and include types, external functions, and functions
		- (none):
			- on tls: same as 'local'
			- in types: same as 'public'
		- private:
			- on tls: only valid for nested types (if I add them); only visible to owning type; cannot be imported
			- in types: only visible to owning type
		- public:
			- on tls: visible anywhere; may be imported
			- in types: visible anywhere
		- local: visible anywhere in the file it's declared in; cannot be imported
			- within a type marked with 'local', all 'public' access is equivalent to 'local'
		- internal: visible in the top-most module it's declared in and its children modules; may be imported
			- if defined in 'mod.a.b', visible to 'mod' and all children of 'mod'
			- within a type marked with 'internal', all 'public' access is equivalent to 'internal'
		- restricted: visible in the module it's declared in and its children modules; may be imported
			- if defined in 'mod.a.b', visible to 'mod.a.b' and all children of 'mod.a.b'
			- within a type marked with 'restricted', all 'public' access is equivalent to 'restricted'
	- return type inference
	- error on cyclic references
	- resolver should be able to determine constant expressions
	- move size resolution into resolver
		- utilize as many passes as needed until count of unresolved sizes reaches 0
		- keep track of already visited types; skip them
*/
module hello.World

var struct Vec2
{
	const a:int = 3 + 5
	var x:int
	var y:int
	n:string
	
	constructor(x:int, y:int, n:string)
	{
		this.x = x
		this.y = y
		this.n = n
	}
	
	operator(left:Vec2 + right:Vec2) :> Vec2 => Vec2.new(left.x + right.x, left.y + right.y, "add")
	operator(left:Vec2 * right:int) :> Vec2 => Vec2.new(left.x * right, left.y * right, "multiply")
	operator(left:int * right:Vec2) :> Vec2 => Vec2.new(left * right.x, left * right.y, "multiply")
	
	string() => n//"({x}, {y})"
}

entry()
{
	print("Hello, World!\n")
	/*let vec = 5 * Vec2.new(1, 2, "a") + Vec2.new(3, 5, "b")
	print("(")
	printInt(vec.x)
	print(", ")
	printInt(vec.y)
	print(")\n")
	print(vec.string())*/
	let vec = Vec2.new(1, 2, "ab")
	print(vec.string())
	printInt(strlen("Hello!"))
	printInt(Vec2.a)
	
	return 0
}

// 65001u = UTF8
var fun setConsoleOutputEncoding(codePage:uint) external(entry = "set_console_output_encoding")
var fun getConsoleOutputEncoding() :> uint external(entry = "get_console_output_encoding")
var fun getCurrentTime() :> int64 external(entry = "get_current_time")
var fun print(text:string) external(entry = "print")
var fun strlen(text:string) :> uint external(entry = "strlen")
var fun printInt(value:int) external(entry = "print_int")
var fun printInt64(value:int64) external(entry = "print_long_long")