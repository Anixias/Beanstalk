/*
Todo:
	- built-in casts
	- built-in operations (in progress)
	- string interpolation
	- visibility/access modifiers
		(tls stands for 'top-level statements' and include types, external functions, functions, and constants
		- (none):
			- on tls: same as 'local'
			- in types: same as 'pub'
		- private:
			- on tls: only valid for nested types (if I add them); only visible to owning type; cannot be imported
			- in types: only visible to owning type
		- pub (public):
			- on tls: visible anywhere; may be imported
			- in types: visible anywhere
		- local: visible anywhere in the file it's declared in; cannot be imported
			- within a type marked with 'local', all 'pub' access is equivalent to 'local'
		- internal: visible in the top-most module it's declared in and its children modules; may be imported
			- if defined in 'mod.a.b', visible to 'mod' and all children of 'mod'
			- within a type marked with 'internal', all 'pub' access is equivalent to 'internal'
		- restricted: visible in the module it's declared in and its children modules; may be imported
			- if defined in 'mod.a.b', visible to 'mod.a.b' and all children of 'mod.a.b'
			- within a type marked with 'restricted', all 'pub' access is equivalent to 'restricted'
	- return type inference
	- default keyword
	- error on cyclic references
	- resolver should be able to determine constant expressions
	- move size resolution into resolver
		- utilize as many passes as needed until count of unresolved sizes reaches 0
		- keep track of already visited types; skip them
	- switch statement
		- if all cases are compile-time constants:
			- can be compiled directly to llvm ir
		- if all cases are types:
			- can be compiled directly to llvm ir because types have a unique numeric identifier that is constant
		- if some cases are compile-time constants:
			- create a switch statement with a case for each constant
			- create a default case that forms an if-else chain for the non-constant cases (final else for default case)
		- if no cases are compile-time constants:
			- form an if-else chain (final else for default case)
	- nullable function calls: doSomething?()
		- the '?' means the function is only called if it is not null (ex: the variable stores a lambda)
	- add '!' postfix unary operator that converts T? into T for remaining control flow branch
*/
import bs.io.Console

module hello.World

/*struct Owner
{
	v:Vec2 = Vec2.new(0, 0)
	i:int = 3
	
	constructor()
	{
	}
}

var struct Vec2
{
	const a:int = 3 + 5
	var x:int
	var y:int
	
	
	constructor(x:int, y:int)
	{
		this.x = x
		this.y = y
	}
	
	//operator(left:Vec2 + right:Vec2) :> Vec2 => Vec2.new(left.x + right.x, left.y + right.y, "add")
	//operator(left:Vec2 * right:int) :> Vec2 => Vec2.new(left.x * right, left.y * right, "multiply")
	//operator(left:int * right:Vec2) :> Vec2 => Vec2.new(left * right.x, left * right.y, "multiply")
	
	string() => "test"//"({x}, {y})"
}*/

const StdIn = -10
const StdOut = -11
const StdErr = -12

const CodePageUTF8 = 65001

import("kernel32.dll")
{
	var fun WriteConsole(handle:nuint, buffer:string, charCount:uint32, charsWritten:uint32?, reserved:nuint) =>
		external(entry = "WriteConsoleA")
		
	var fun SetConsoleOutputCodePage(codePage:uint32) =>
		external(entry = "SetConsoleOutputCP")
		
	fun GetStdHandle(handle:uint32) :> nuint =>
		external(entry = "GetStdHandle")
}

entry()
{
	SetConsoleOutputCodePage(CodePageUTF8)
	let stdOut = GetStdHandle(StdOut)
	WriteConsole(stdOut, "Hello, World!\n", 14u32, null, 0u64)
	WriteConsole(stdOut, "This is a test", 14u32, null, 0u64)
	
	Console.Out.PrintLine("Hello, World!")
	
	return 0
}